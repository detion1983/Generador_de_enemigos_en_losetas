<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Enemigos en Losetas</title>
    <style>
        /* (Mantener todos los estilos CSS existentes) */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            padding: 20px;
            min-height: 100vh;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        /* (Resto de estilos sin cambios) */
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Generador de Enemigos en Losetas</h1>
            <p class="subtitle">Selecciona el nivel de héroes, tipo de enemigos y una loseta</p>
        </header>
        
        <div class="controls">
            <div class="select-group">
                <label for="nivel-heroes">Nivel de Héroes:</label>
                <select id="nivel-heroes">
                    <option value="">Selecciona nivel</option>
                    <option value="1">Nivel 1</option>
                    <option value="2">Nivel 2</option>
                    <option value="3">Nivel 3</option>
                    <option value="4">Nivel 4</option>
                    <option value="5">Nivel 5</option>
                    <option value="6">Nivel 6</option>
                    <option value="7">Nivel 7</option>
                    <option value="8">Nivel 8</option>
                    <option value="9">Nivel 9</option>
                    <option value="10">Nivel 10</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="tipo-enemigo">Tipo de Enemigos:</label>
                <select id="tipo-enemigo">
                    <option value="">Selecciona un tipo</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="loseta">Loseta:</label>
                <select id="loseta">
                    <option value="">Selecciona una loseta</option>
                </select>
            </div>
            
            <button id="generar-btn">Generar Enemigos</button>
        </div>
        
        <div class="visualization">
            <div class="loseta-container">
                <h3 class="loseta-title" id="loseta-title">Selecciona una loseta</h3>
                <div id="matriz-loseta" class="matriz"></div>
            </div>
            
            <div class="info-panel">
                <h3>Enemigos Generados</h3>
                <div id="tirada-info" class="tirada-info" style="display: none;">
                    <strong>Información de la tirada:</strong><br>
                    <span id="tirada-detalle"></span>
                </div>
                <div id="enemigos-lista"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <span class="stat-value" id="total-enemigos">0</span>
                <span class="stat-label">Total Enemigos</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="nivel-promedio">0</span>
                <span class="stat-label">Nivel Promedio</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="casillas-ocupadas">0%</span>
                <span class="stat-label">Casillas Ocupadas</span>
            </div>
        </div>
        
        <footer>
            <p>Proyecto de Visualización de Enemigos &copy; 2023</p>
        </footer>
    </div>

    <script>
        // Variables globales
        let enemigosData = {};
        let losetasData = {};
        let enemigosCargados = [];
        let losetaSeleccionada = null;
        let nivelHeroes = 0;
        const isGitHubPages = window.location.hostname.includes('github.io');
        const IMAGES_BASE_PATH = isGitHubPages ? 'images/losetas/' : 'images/losetas/';

        // Cargar datos iniciales
        document.addEventListener('DOMContentLoaded', () => {
            cargarTiposEnemigos();
            cargarLosetas();
            
            document.getElementById('nivel-heroes').addEventListener('change', (e) => {
                nivelHeroes = parseInt(e.target.value) || 0;
            });
            
            document.getElementById('generar-btn').addEventListener('click', generarEnemigos);
        });

        // Cargar tipos de enemigos disponibles
        async function cargarTiposEnemigos() {
            try {
                // Lista de tipos de enemigos disponibles
                const tipos = ['bandidos', 'bestias', 'elfos_oscuros', 'no_muertos', 'orcos_goblins', 'reptiles', 'tierras_antiguas'];
                const select = document.getElementById('tipo-enemigo');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                tipos.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo;
                    option.textContent = tipo.charAt(0).toUpperCase() + tipo.slice(1).replace(/_/g, ' ');
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarEnemigos(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando tipos de enemigos:', error);
            }
        }

        // Cargar enemigos desde JSON
        async function cargarEnemigos(tipo) {
            try {
                const ruta = isGitHubPages ? `data/${tipo}.json` : `data\\${tipo}.json`;
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar ${tipo}.json: ${response.status}`);
                }
                enemigosData = await response.json();
                console.log(`Enemigos de tipo ${tipo} cargados:`, enemigosData);
            } catch (error) {
                console.error('Error cargando enemigos:', error);
                alert(`Error al cargar los datos de ${tipo}.`);
            }
        }

        // Cargar losetas disponibles
        async function cargarLosetas() {
            try {
                const ruta = isGitHubPages ? 'data/losetas.json' : 'data\\losetas.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar losetas.json: ${response.status}`);
                }
        
                const data = await response.json();
                losetasData = data.losetas;
                
                // Ordenar losetas alfabéticamente por nombre
                losetasData.sort((a, b) => a.nombre.localeCompare(b.nombre));
                
                const select = document.getElementById('loseta');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                losetasData.forEach(loseta => {
                    const option = document.createElement('option');
                    option.value = loseta.nombre;
                    option.textContent = loseta.nombre;
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarLoseta(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando losetas:', error);
                alert('Error al cargar las losetas.');
            }
        }

        // Cargar loseta específica
        async function cargarLoseta(nombre) {
            try {
                // Buscar la loseta por nombre
                const loseta = losetasData.find(l => l.nombre === nombre);
                if (!loseta) {
                    throw new Error(`Loseta ${nombre} no encontrada`);
                }
                
                losetaSeleccionada = loseta;
                document.getElementById('loseta-title').textContent = losetaSeleccionada.nombre;
                visualizarLoseta(losetaSeleccionada);
                console.log(`Loseta ${nombre} cargada:`, losetaSeleccionada);
            } catch (error) {
                console.error('Error cargando loseta:', error);
                alert(`Error al cargar la loseta ${nombre}.`);
            }
        }

        // Visualizar la loseta con su matriz
        function visualizarLoseta(loseta) {
            const matrizContainer = document.getElementById('matriz-loseta');
            matrizContainer.innerHTML = '';
            
            // Usar la ruta base correcta según el entorno
            const rutaImagen = `${IMAGES_BASE_PATH}${loseta.imagen}`;
            matrizContainer.style.backgroundImage = `url(${rutaImagen})`;
            
            // Determinar dimensiones de la matriz
            const filas = loseta.matriz.length;
            const columnas = loseta.matriz[0].length;
            
            // Actualizar la cuadrícula CSS para que coincida con las dimensiones de la loseta
            matrizContainer.style.gridTemplateColumns = `repeat(${columnas}, 1fr)`;
            matrizContainer.style.gridTemplateRows = `repeat(${filas}, 1fr)`;
            
            // Crear casillas
            for (let i = 0; i < filas; i++) {
                for (let j = 0; j < columnas; j++) {
                    const casilla = document.createElement('div');
                    casilla.className = 'casilla';
                    casilla.dataset.fila = i;
                    casilla.dataset.columna = j;
                    
                    if (loseta.matriz[i][j] === 0) {
                        casilla.classList.add('invalida');
                    }
                    
                    matrizContainer.appendChild(casilla);
                }
            }
        }

        // (El resto de funciones permanecen igual)
        // Realizar tirada de dado de 20 caras
        function tirarD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        // Calcular tirada según nivel de héroes
        function calcularTirada() {
            if (nivelHeroes < 1) return 0;
            
            const tiradaDado = tirarD20();
            const modificador = (nivelHeroes - 1) * 10;
            const tiradaFinal = tiradaDado + modificador;
            
            return {
                dado: tiradaDado,
                modificador: modificador,
                total: tiradaFinal
            };
        }

        // Encontrar encuentro según tirada
        function encontrarEncuentroPorTirada(tirada) {
            if (!enemigosData.encuentros) return null;
            
            for (const encuentro of enemigosData.encuentros) {
                const [min, max] = encuentro.tirada.split('-').map(Number);
                if (tirada >= min && tirada <= max) {
                    return encuentro;
                }
            }
            
            // Si no encuentra ningún encuentro, devolver el último
            return enemigosData.encuentros[enemigosData.encuentros.length - 1];
        }

        // Obtener dimensiones según el tipo de enemigo
        function obtenerDimensionesEnemigo(tamano) {
            switch (tamano) {
                case 'ENORME': 
                    return { ancho: 2, alto: 2, casillas: 4 };
                case 'EXTRAENORME': 
                    return { ancho: 3, alto: 2, casillas: 6 };
                default: 
                    return { ancho: 1, alto: 1, casillas: 1 };
            }
        }

        // Verificar si un área está disponible para colocar un enemigo
        function areaDisponible(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    // Verificar si está dentro de los límites
                    if (fila >= losetaSeleccionada.matriz.length || columna >= losetaSeleccionada.matriz[0].length) {
                        return false;
                    }
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    
                    if (!casilla || 
                        casilla.classList.contains('invalida') || 
                        casilla.classList.contains('ocupada')) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Marcar área como ocupada
        function marcarAreaOcupada(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    if (casilla) {
                        casilla.classList.add('ocupada');
                    }
                }
            }
        }

        // Función mejorada para procesar expresiones de dados
        function procesarExpresionDados(expresion) {
            let cantidad = 0;
            
            // Patrones para diferentes tipos de expresiones
            const patrones = [
                // Patrón para "1d4+1" o "2d6+3"
                /(\d+)d(\d+)\+(\d+)/,
                // Patrón para "1d4" o "2d6"  
                /(\d+)d(\d+)/,
                // Patrón para números simples "3" o "12"
                /(\d+)/
            ];
            
            for (const patron of patrones) {
                const match = expresion.match(patron);
                if (match) {
                    if (match[3]) {
                        // Formato: XdY+Z
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        const bonus = parseInt(match[3]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                        cantidad += bonus;
                    } else if (match[2]) {
                        // Formato: XdY
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                    } else {
                        // Formato: número simple
                        cantidad = parseInt(match[1]);
                    }
                    break;
                }
            }
            
            return cantidad;
        }

        // Función mejorada para procesar descripción de encuentro (mantiene equipo pero no lo trata como enemigos)
        function procesarDescripcionEncuentro(descripcion) {
            const enemigos = [];
            
            // Dividir la descripción en partes principales (usando "y" como separador principal)
            const partesPrincipales = descripcion.split(/(?:\s+y\s+)/);
            
            for (const partePrincipal of partesPrincipales) {
                // Para cada parte principal, buscar expresiones de dados
                const patronDadosGlobal = /(\d+d\d+\+\d+|\d+d\d+|\d+)\s*([^()]+?)(?=\s*(?:\d+d\d+\+\d+|\d+d\d+|\d+|\s*y\s+|$))/g;
                
                let match;
                while ((match = patronDadosGlobal.exec(partePrincipal)) !== null) {
                    const expresion = match[1];
                    let nombreEnemigo = match[2].trim();
                    
                    // Limpiar posibles conectores al final
                    nombreEnemigo = nombreEnemigo.replace(/\s*(?:,|;|y|$)\s*$/, '');
                    
                    if (nombreEnemigo && nombreEnemigo.length > 1) {
                        const cantidad = procesarExpresionDados(expresion);
                        
                        // Añadir cada enemigo individualmente con la descripción COMPLETA
                        for (let i = 0; i < cantidad; i++) {
                            enemigos.push({
                                nombre: nombreEnemigo, // Este es el nombre base sin equipo
                                descripcionCompleta: partePrincipal.trim(), // Mantenemos la descripción completa con equipo
                                nivel: nivelHeroes,
                                tamano: 'NORMAL'
                            });
                        }
                    }
                }
                
                // Si no encontramos patrones de dados pero la parte es significativa
                if (enemigos.length === 0 && partePrincipal.trim().length > 2) {
                    // Buscar si hay un número simple al inicio
                    const matchNumeroSimple = partePrincipal.match(/^(\d+)\s+(.+)$/);
                    if (matchNumeroSimple) {
                        const cantidad = parseInt(matchNumeroSimple[1]);
                        const nombreEnemigo = matchNumeroSimple[2].trim();
                        
                        for (let i = 0; i < cantidad; i++) {
                            enemigos.push({
                                nombre: nombreEnemigo,
                                descripcionCompleta: partePrincipal.trim(),
                                nivel: nivelHeroes,
                                tamano: 'NORMAL'
                            });
                        }
                    } else {
                        // Si no hay número, asumir 1 enemigo
                        enemigos.push({
                            nombre: partePrincipal.trim(),
                            descripcionCompleta: partePrincipal.trim(),
                            nivel: nivelHeroes,
                            tamano: 'NORMAL'
                        });
                    }
                }
            }
            
            return enemigos;
        }

        // Generar enemigos basados en las probabilidades
        function generarEnemigos() {
            if (!enemigosData.encuentros || !losetaSeleccionada || nivelHeroes < 1) {
                alert('Por favor, selecciona nivel de héroes, tipo de enemigos y loseta.');
                return;
            }
            
            // Limpiar enemigos anteriores
            document.querySelectorAll('.enemigo').forEach(el => el.remove());
            document.querySelectorAll('.casilla.ocupada').forEach(el => el.classList.remove('ocupada'));
            document.getElementById('enemigos-lista').innerHTML = '';
            enemigosCargados = [];
            
            // Realizar tirada según nivel de héroes
            const tirada = calcularTirada();
            const encuentro = encontrarEncuentroPorTirada(tirada.total);
            
            if (!encuentro) {
                alert('No se pudo encontrar un encuentro para la tirada realizada.');
                return;
            }
            
            // Mostrar información de la tirada
            document.getElementById('tirada-info').style.display = 'block';
            document.getElementById('tirada-detalle').innerHTML = `
                Nivel héroes: ${nivelHeroes}<br>
                Tirada D20: ${tirada.dado}<br>
                Modificador: +${tirada.modificador}<br>
                <strong>Total: ${tirada.total}</strong><br>
                Encuentro: ${encuentro.descripcion}
            `;
            
            // Procesar la descripción del encuentro para obtener enemigos
            const enemigos = procesarDescripcionEncuentro(encuentro.descripcion);
            
            if (enemigos.length === 0) {
                alert('No se pudieron procesar los enemigos de este encuentro.');
                return;
            }
            
            // Ordenar enemigos por tamaño (los más grandes primero)
            enemigos.sort((a, b) => {
                const sizeOrder = { 'NORMAL': 1, 'ENORME': 2, 'EXTRAENORME': 3 };
                return sizeOrder[b.tamano] - sizeOrder[a.tamano];
            });
            
            // Colocar enemigos
            for (const enemigo of enemigos) {
                const colocado = colocarEnemigo(enemigo);
                if (!colocado) {
                    console.warn('No se pudo colocar el enemigo:', enemigo.nombre);
                    // Continuar intentando con los demás enemigos
                }
            }
            
            // Mostrar lista de enemigos
            mostrarListaEnemigos();
            actualizarEstadisticas();
        }

        // Colocar enemigo en una casilla válida aleatoria
        function colocarEnemigo(enemigo) {
            // Encontrar todas las casillas válidas y disponibles
            const casillasValidas = [];
            const casillas = document.querySelectorAll('.casilla:not(.invalida):not(.ocupada)');
            
            casillas.forEach(casilla => {
                casillasValidas.push(casilla);
            });
            
            if (casillasValidas.length === 0) {
                console.warn('No hay casillas disponibles para colocar enemigos');
                return false;
            }
            
            // Mezclar casillas para obtener una posición aleatoria
            for (let i = casillasValidas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [casillasValidas[i], casillasValidas[j]] = [casillasValidas[j], casillasValidas[i]];
            }
            
            // Intentar colocar el enemigo
            for (const casilla of casillasValidas) {
                const fila = parseInt(casilla.dataset.fila);
                const columna = parseInt(casilla.dataset.columna);
                
                if (areaDisponible(fila, columna, enemigo.tamano)) {
                    // Marcar área como ocupada
                    marcarAreaOcupada(fila, columna, enemigo.tamano);
                    
                    // Obtener dimensiones
                    const dimensiones = obtenerDimensionesEnemigo(enemigo.tamano);
                    
                    // Crear elemento visual para el enemigo
                    const enemigoElement = document.createElement('div');
                    enemigoElement.className = `enemigo ${enemigo.tamano.toLowerCase()}`;
                    enemigoElement.title = `${enemigo.nombre} (${enemigo.tamano})`;
                    
                    // Calcular posición y tamaño
                    const matrizContainer = document.getElementById('matriz-loseta');
                    const cellWidth = matrizContainer.offsetWidth / losetaSeleccionada.matriz[0].length;
                    const cellHeight = matrizContainer.offsetHeight / losetaSeleccionada.matriz.length;
                    
                    enemigoElement.style.width = `${dimensiones.ancho * cellWidth - 4}px`;
                    enemigoElement.style.height = `${dimensiones.alto * cellHeight - 4}px`;
                    enemigoElement.style.left = `${columna * cellWidth + 2}px`;
                    enemigoElement.style.top = `${fila * cellHeight + 2}px`;
                    
                    // Usar iniciales para mostrar en el rectángulo
                    const iniciales = enemigo.nombre.split(' ').map(p => p[0]).join('').toUpperCase().substring(0, 3);
                    enemigoElement.textContent = iniciales;
                    
                    matrizContainer.appendChild(enemigoElement);
                    
                    // Guardar información del enemigo
                    enemigosCargados.push({
                        nombre: enemigo.nombre,
                        nivel: enemigo.nivel,
                        tamano: enemigo.tamano,
                        fila: fila,
                        columna: columna,
                        casillasOcupadas: dimensiones.casillas,
                        ancho: dimensiones.ancho,
                        alto: dimensiones.alto
                    });
                    
                    return true;
                }
            }
            
            return false;
        }

        // Mostrar lista de enemigos generados
        function mostrarListaEnemigos() {
            const listaContainer = document.getElementById('enemigos-lista');
            
            if (enemigosCargados.length === 0) {
                listaContainer.innerHTML = '<p>No se generaron enemigos.</p>';
                return;
            }
            
            enemigosCargados.forEach(enemigo => {
                const item = document.createElement('div');
                item.className = 'enemigo-item';
                item.innerHTML = `
                    <strong>${enemigo.descripcionCompleta || enemigo.nombre}</strong> (Nivel ${enemigo.nivel}, ${enemigo.tamano})<br>
                    Posición: Fila ${enemigo.fila + 1}, Columna ${enemigo.columna + 1}<br>
                    Dimensiones: ${enemigo.ancho}x${enemigo.alto} casillas<br>
                    Casillas ocupadas: ${enemigo.casillasOcupadas}
                `;
                listaContainer.appendChild(item);
            });
        }

        // Actualizar estadísticas
        function actualizarEstadisticas() {
            // Total de enemigos
            document.getElementById('total-enemigos').textContent = enemigosCargados.length;
            
            // Nivel promedio
            if (enemigosCargados.length > 0) {
                const sumaNiveles = enemigosCargados.reduce((sum, enemigo) => sum + enemigo.nivel, 0);
                const promedio = (sumaNiveles / enemigosCargados.length).toFixed(1);
                document.getElementById('nivel-promedio').textContent = promedio;
            } else {
                document.getElementById('nivel-promedio').textContent = '0';
            }
            
            // Porcentaje de casillas ocupadas
            let casillasValidas = 0;
            let casillasOcupadas = 0;
            
            for (let i = 0; i < losetaSeleccionada.matriz.length; i++) {
                for (let j = 0; j < losetaSeleccionada.matriz[i].length; j++) {
                    if (losetaSeleccionada.matriz[i][j] === 1) {
                        casillasValidas++;
                    }
                }
            }
            
            enemigosCargados.forEach(enemigo => {
                casillasOcupadas += enemigo.casillasOcupadas;
            });
            
            const porcentaje = Math.round((casillasOcupadas / casillasValidas) * 100);
            document.getElementById('casillas-ocupadas').textContent = `${porcentaje}%`;
        }
    </script>
</body>
</html>