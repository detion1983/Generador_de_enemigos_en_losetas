<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Tile Generator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #fff;
            background: url('images/interface/fondo_losetas.jpg') no-repeat center center fixed;
            background-size: cover;
            padding: 20px;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: -1;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(35, 35, 35, 0.1);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #8B4513;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #8B4513;
        }

        .titulo-container {
            width: 80%;
            max-width: 800px;
            height: 120px;
            margin: 0 auto 20px;
            background: url('images/interface/titulo_losetas.png') no-repeat center center;
            background-size: contain;
        }

        .subtitle {
            color: #d4af37;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px #000;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 40px;
            padding: 25px;
            background: rgba(60, 60, 60, 0.1);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
        }

        .select-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 1px 1px 1px #000;
        }

        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #5D4037;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
            background: rgba(40, 40, 40, 0.9);
            color: #fff;
            background-image: url('images/interface/select_arrow.png');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 35px;
        }

        select:focus {
            border-color: #d4af37;
            outline: none;
        }

        .btn-container {
            display: flex;
            align-items: flex-end;
        }

        .btn {
            width: 180px;
            height: 60px;
            background: url('images/interface/btn_generar.png') no-repeat center center;
            background-size: contain;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.05);
            filter: brightness(1.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }

        .loseta-container {
            flex: 2;
            min-width: 300px;
            background: rgba(60, 60, 60, 0.1);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            position: relative;
            border: 1px solid #5D4037;
        }

        .loseta-title {
            text-align: center;
            margin-bottom: 15px;
            color: #d4af37;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px #000;
        }

        .matriz {
            display: grid;
            gap: 2px;
            background: transparent;
            padding: 8px;
            border-radius: 8px;
            min-height: 350px;
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            width: 100%;
        }

        .casilla {
            aspect-ratio: 1/1;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 3px;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .casilla:hover {
            transform: scale(1.02);
            z-index: 1;
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 3px rgba(255, 215, 0, 0.5);
        }

        .casilla.invalida {
            background: rgba(0, 0, 0, 0.2);
            border: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .casilla.ocupada {
            background: rgba(231, 76, 60, 0.3);
        }

        .enemigo {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            animation: aparecer 0.5s ease-out;
            z-index: 2;
            border: 2px solid rgba(0, 0, 0, 0.5);
            padding: 5px;
            box-sizing: border-box;
        }

        .enemigo.normal {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-radius: 8px;
            font-size: 14px;
        }

        .enemigo.enorme {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border-radius: 10px;
            font-size: 16px;
        }

        .enemigo.extraenorme {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            border-radius: 12px;
            font-size: 18px;
        }

        @keyframes aparecer {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .info-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(60, 60, 60, 0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #5D4037;
        }

        .info-panel h3 {
            color: #d4af37;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #8B4513;
            text-align: center;
            text-shadow: 1px 1px 2px #000;
        }

        #enemigos-lista {
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .enemigo-item {
            padding: 12px;
            margin-bottom: 12px;
            background: rgba(40, 40, 40, 0.8);
            border-left: 5px solid #e74c3c;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
            color: #fff;
        }

        .enemigo-item:hover {
            transform: translateX(5px);
        }

        .enemigo-item strong {
            color: #d4af37;
            display: block;
            margin-bottom: 5px;
        }

        .tirada-info {
            background: rgba(52, 152, 219, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            color: #fff;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            background: rgba(52, 73, 94, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            border: 1px solid #5D4037;
        }

        .stat-item {
            flex: 1;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            display: block;
            color: #d4af37;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        @media (max-width: 992px) {
            .visualization {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn-container {
                align-self: stretch;
            }
            
            .btn {
                width: 100%;
            }
        }

        footer {
            text-align: center;
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="titulo-container"></div>
            <p class="subtitle">Selecciona el nivel de héroes, tipo de enemigos y una loseta</p>
        </header>
        
        <div class="controls">
            <div class="select-group">
                <label for="nivel-heroes">Nivel de Héroes:</label>
                <select id="nivel-heroes">
                    <option value="">Selecciona nivel</option>
                    <option value="1">Nivel 1</option>
                    <option value="2">Nivel 2</option>
                    <option value="3">Nivel 3</option>
                    <option value="4">Nivel 4</option>
                    <option value="5">Nivel 5</option>
                    <option value="6">Nivel 6</option>
                    <option value="7">Nivel 7</option>
                    <option value="8">Nivel 8</option>
                    <option value="9">Nivel 9</option>
                    <option value="10">Nivel 10</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="tipo-enemigo">Tipo de Enemigos:</label>
                <select id="tipo-enemigo">
                    <option value="">Selecciona un tipo</option>
                </select>
            </div>
            
            <div class="select-group">
                <label for="loseta">Loseta:</label>
                <select id="loseta">
                    <option value="">Selecciona una loseta</option>
                </select>
            </div>
            
            <div class="btn-container">
                <button id="generar-btn" class="btn"></button>
            </div>
        </div>
        
        <div class="visualization">
            <div class="loseta-container">
                <h3 class="loseta-title" id="loseta-title">Selecciona una loseta</h3>
                <div id="matriz-loseta" class="matriz"></div>
            </div>
            
            <div class="info-panel">
                <h3>Enemigos Generados</h3>
                <div id="tirada-info" class="tirada-info" style="display: none;">
                    <strong>Información de la tirada:</strong><br>
                    <span id="tirada-detalle"></span>
                </div>
                <div id="enemigos-lista"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <span class="stat-value" id="total-enemigos">0</span>
                <span class="stat-label">Total Enemigos</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="nivel-promedio">0</span>
                <span class="stat-label">Nivel Promedio</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="casillas-ocupadas">0%</span>
                <span class="stat-label">Casillas Ocupadas</span>
            </div>
        </div>
        
        <footer>
            <p>Proyecto de Visualización de Enemigos &copy; 2023</p>
        </footer>
    </div>

    <script>
        // Variables globales
        let enemigosData = {};
        let losetasData = {};
        let tamanosMonstruos = {};
        let enemigosCargados = [];
        let losetaSeleccionada = null;
        let nivelHeroes = 0;
        const isGitHubPages = window.location.hostname.includes('github.io');

        // Cargar datos iniciales
        document.addEventListener('DOMContentLoaded', async () => {
            await cargarTamanosMonstruos();
            cargarTiposEnemigos();
            cargarLosetas();
            
            document.getElementById('nivel-heroes').addEventListener('change', (e) => {
                nivelHeroes = parseInt(e.target.value) || 0;
            });
            
            document.getElementById('generar-btn').addEventListener('click', generarEnemigos);
        });

        // Cargar tamaños de monstruos
        async function cargarTamanosMonstruos() {
            try {
                const ruta = isGitHubPages ? 'data/tamanos_monstruos.json' : 'data\\tamanos_monstruos.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar tamanos_monstruos.json: ${response.status}`);
                }
                
                const data = await response.json();
                tamanosMonstruos = data.tamaños;
                console.log('Tamaños de monstruos cargados:', tamanosMonstruos);
            } catch (error) {
                console.error('Error cargando tamaños de monstruos:', error);
                alert('Error al cargar los tamaños de monstruos.');
            }
        }

        // Obtener el tamaño de un monstruo por su nombre
        function obtenerTamanoMonstruo(nombre) {
            // Buscar coincidencia exacta
            if (tamanosMonstruos[nombre]) {
                return tamanosMonstruos[nombre];
            }
            
            // Buscar coincidencias parciales
            for (const key in tamanosMonstruos) {
                if (nombre.includes(key) || key.includes(nombre)) {
                    return tamanosMonstruos[key];
                }
            }
            
            // Si no se encuentra, devolver NORMAL por defecto
            return "NORMAL";
        }

        // Cargar tipos de enemigos disponibles
        async function cargarTiposEnemigos() {
            try {
                // Lista de tipos de enemigos disponibles
                const tipos = ['bandidos', 'bestias', 'elfos_oscuros', 'no_muertos', 'orcos_goblins', 'reptiles', 'tierras_antiguas'];
                const select = document.getElementById('tipo-enemigo');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                tipos.forEach(tipo => {
                    const option = document.createElement('option');
                    option.value = tipo;
                    option.textContent = tipo.charAt(0).toUpperCase() + tipo.slice(1).replace(/_/g, ' ');
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarEnemigos(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando tipos de enemigos:', error);
            }
        }

        // Cargar enemigos desde JSON
        async function cargarEnemigos(tipo) {
            try {
                const ruta = isGitHubPages ? `data/${tipo}.json` : `data\\${tipo}.json`;
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar ${tipo}.json: ${response.status}`);
                }
                enemigosData = await response.json();
                console.log(`Enemigos de tipo ${tipo} cargados:`, enemigosData);
            } catch (error) {
                console.error('Error cargando enemigos:', error);
                alert(`Error al cargar los datos de ${tipo}.`);
            }
        }

        // Cargar losetas disponibles
        async function cargarLosetas() {
            try {
                const ruta = isGitHubPages ? 'data/losetas.json' : 'data\\losetas.json';
                const response = await fetch(ruta);
                
                if (!response.ok) {
                    throw new Error(`Error al cargar losetas.json: ${response.status}`);
                }
        
                const data = await response.json();
                losetasData = data.losetas;
                
                // Ordenar losetas alfabéticamente por nombre
                losetasData.sort((a, b) => a.nombre.localeCompare(b.nombre));
                
                const select = document.getElementById('loseta');
                
                // Limpiar opciones existentes (excepto la primera)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Añadir opciones
                losetasData.forEach(loseta => {
                    const option = document.createElement('option');
                    option.value = loseta.nombre;
                    option.textContent = loseta.nombre;
                    select.appendChild(option);
                });
                
                select.addEventListener('change', async (e) => {
                    if (e.target.value) {
                        await cargarLoseta(e.target.value);
                    }
                });
            } catch (error) {
                console.error('Error cargando losetas:', error);
                alert('Error al cargar las losetas.');
            }
        }

        // Cargar loseta específica
        async function cargarLoseta(nombre) {
            try {
                // Buscar la loseta por nombre
                const loseta = losetasData.find(l => l.nombre === nombre);
                if (!loseta) {
                    throw new Error(`Loseta ${nombre} no encontrada`);
                }
                
                losetaSeleccionada = loseta;
                document.getElementById('loseta-title').textContent = losetaSeleccionada.nombre;
                visualizarLoseta(losetaSeleccionada);
                console.log(`Loseta ${nombre} cargada:`, losetaSeleccionada);
            } catch (error) {
                console.error('Error cargando loseta:', error);
                alert(`Error al cargar la loseta ${nombre}.`);
            }
        }

        // Visualizar la loseta con su matriz
        function visualizarLoseta(loseta) {
            const matrizContainer = document.getElementById('matriz-loseta');
            matrizContainer.innerHTML = '';
            
            const rutaImagen = isGitHubPages ? 
                `images/losetas/${loseta.imagen}.png` : 
                `images/losetas/${loseta.imagen}.png`;
            
            // Crear una imagen para precargarla y verificar si existe
            const img = new Image();
            img.onload = function() {
                matrizContainer.style.backgroundImage = `url(${rutaImagen})`;
                matrizContainer.style.backgroundSize = '100% 100%';
            };
            img.onerror = function() {
                console.warn(`No se pudo cargar la imagen: ${rutaImagen}`);
                matrizContainer.style.backgroundImage = 'none';
            };
            img.src = rutaImagen;
            
            // Determinar dimensiones de la matriz
            const filas = loseta.matriz.length;
            const columnas = loseta.matriz[0].length;
            
            // Actualizar la cuadrícula CSS para que coincida con las dimensiones de la loseta
            matrizContainer.style.gridTemplateColumns = `repeat(${columnas}, 1fr)`;
            matrizContainer.style.gridTemplateRows = `repeat(${filas}, 1fr)`;
            
            // Crear casillas
            for (let i = 0; i < filas; i++) {
                for (let j = 0; j < columnas; j++) {
                    const casilla = document.createElement('div');
                    casilla.className = 'casilla';
                    casilla.dataset.fila = i;
                    casilla.dataset.columna = j;
                    
                    if (loseta.matriz[i][j] === 0) {
                        casilla.classList.add('invalida');
                    }
                    
                    matrizContainer.appendChild(casilla);
                }
            }
        }

        // Realizar tirada de dado de 20 caras
        function tirarD20() {
            return Math.floor(Math.random() * 20) + 1;
        }

        // Calcular tirada según nivel de héroes
        function calcularTirada() {
            if (nivelHeroes < 1) return 0;
            
            const tiradaDado = tirarD20();
            const modificador = (nivelHeroes - 1) * 10;
            const tiradaFinal = tiradaDado + modificador;
            
            return {
                dado: tiradaDado,
                modificador: modificador,
                total: tiradaFinal
            };
        }

        // Encontrar encuentro según tirada
        function encontrarEncuentroPorTirada(tirada) {
            if (!enemigosData.encuentros) return null;
            
            for (const encuentro of enemigosData.encuentros) {
                const [min, max] = encuentro.tirada.split('-').map(Number);
                if (tirada >= min && tirada <= max) {
                    return encuentro;
                }
            }
            
            // Si no encuentra ningún encuentro, devolver el último
            return enemigosData.encuentros[enemigosData.encuentros.length - 1];
        }

        // Obtener dimensiones según el tipo de enemigo
        function obtenerDimensionesEnemigo(tamano) {
            switch (tamano) {
                case 'ENORME': 
                    return { ancho: 2, alto: 2, casillas: 4 };
                case 'EXTRAENORME': 
                    return { ancho: 3, alto: 2, casillas: 6 };
                default: 
                    return { ancho: 1, alto: 1, casillas: 1 };
            }
        }

        // Verificar si un área está disponible para colocar un enemigo
        function areaDisponible(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    // Verificar si está dentro de los límites
                    if (fila >= losetaSeleccionada.matriz.length || columna >= losetaSeleccionada.matriz[0].length) {
                        return false;
                    }
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    
                    if (!casilla || 
                        casilla.classList.contains('invalida') || 
                        casilla.classList.contains('ocupada')) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Marcar área como ocupada
        function marcarAreaOcupada(filaInicio, columnaInicio, tamano) {
            const dimensiones = obtenerDimensionesEnemigo(tamano);
            const ancho = dimensiones.ancho;
            const alto = dimensiones.alto;
            
            for (let i = 0; i < alto; i++) {
                for (let j = 0; j < ancho; j++) {
                    const fila = filaInicio + i;
                    const columna = columnaInicio + j;
                    
                    const casilla = document.querySelector(`.casilla[data-fila="${fila}"][data-columna="${columna}"]`);
                    if (casilla) {
                        casilla.classList.add('ocupada');
                    }
                }
            }
        }

        // Función mejorada para procesar expresiones de dados
        function procesarExpresionDados(expresion) {
            let cantidad = 0;
            
            // Patrones para diferentes tipos de expresiones
            const patrones = [
                // Patrón para "1d4+1" o "2d6+3"
                /(\d+)d(\d+)\+(\d+)/,
                // Patrón para "1d4" o "2d6"  
                /(\d+)d(\d+)/,
                // Patrón para números simples "3" or "12"
                /(\d+)/
            ];
            
            for (const patron of patrones) {
                const match = expresion.match(patron);
                if (match) {
                    if (match[3]) {
                        // Formato: XdY+Z
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        const bonus = parseInt(match[3]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                        cantidad += bonus;
                    } else if (match[2]) {
                        // Formato: XdY
                        const numDados = parseInt(match[1]);
                        const carasDado = parseInt(match[2]);
                        
                        for (let i = 0; i < numDados; i++) {
                            cantidad += Math.floor(Math.random() * carasDado) + 1;
                        }
                    } else {
                        // Formato: número simple
                        cantidad = parseInt(match[1]);
                    }
                    break;
                }
            }
            
            return cantidad;
        }

        // Función mejorada para procesar descripción de encuentro
        function procesarDescripcionEncuentro(descripcion) {
            const enemigos = [];
            
            // Dividir la descripción en partes principales (usando "y" como separador principal)
            const partesPrincipales = descripcion.split(/(?:\s+y\s+)/);
            
            for (const partePrincipal of partesPrincipales) {
                // Para cada parte principal, buscar expresiones de dados
                const patronDadosGlobal = /(\d+d\d+\+\d+|\d+d\d+|\d+)\s*([^()]+?)(?=\s*(?:\d+d\d+\+\d+|\d+d\d+|\d+|\s*y\s+|$))/g;
                
                let match;
                while ((match = patronDadosGlobal.exec(partePrincipal)) !== null) {
                    const expresion = match[1];
                    let nombreEnemigo = match[2].trim();
                    
                    // Limpiar posibles conectores al final
                    nombreEnemigo = nombreEnemigo.replace(/\s*(?:,|;|y|$)\s*$/, '');
                    
                    if (nombreEnemigo && nombreEnemigo.length > 1) {
                        const cantidad = procesarExpresionDados(expresion);
                        const tamano = obtenerTamanoMonstruo(nombreEnemigo);
                        
                        // Añadir cada enemigo individualmente con el tamaño correcto
                        for (let i = 0; i < cantidad; i++) {
                            enemigos.push({
                                nombre: nombreEnemigo,
                                descripcionCompleta: partePrincipal.trim(),
                                nivel: nivelHeroes,
                                tamano: tamano
                            });
                        }
                    }
                }
                
                // Si no encontramos patrones de dados pero la parte es significativa
                if (enemigos.length === 0 && partePrincipal.trim().length > 2) {
                    // Buscar si hay un número simple al inicio
                    const matchNumeroSimple = partePrincipal.match(/^(\d+)\s+(.+)$/);
                    if (matchNumeroSimple) {
                        const cantidad = parseInt(matchNumeroSimple[1]);
                        const nombreEnemigo = matchNumeroSimple[2].trim();
                        const tamano = obtenerTamanoMonstruo(nombreEnemigo);
                        
                        for (let i = 0; i < cantidad; i++) {
                            enemigos.push({
                                nombre: nombreEnemigo,
                                descripcionCompleta: partePrincipal.trim(),
                                nivel: nivelHeroes,
                                tamano: tamano
                            });
                        }
                    } else {
                        // Si no hay número, asumir 1 enemigo
                        const tamano = obtenerTamanoMonstruo(partePrincipal.trim());
                        enemigos.push({
                            nombre: partePrincipal.trim(),
                            descripcionCompleta: partePrincipal.trim(),
                            nivel: nivelHeroes,
                            tamano: tamano
                        });
                    }
                }
            }
            
            return enemigos;
        }

        // Generar enemigos basados en las probabilidades
        function generarEnemigos() {
            if (!enemigosData.encuentros || !losetaSeleccionada || nivelHeroes < 1) {
                alert('Por favor, selecciona nivel de héroes, tipo de enemigos y loseta.');
                return;
            }
            
            // Limpiar enemigos anteriores
            document.querySelectorAll('.enemigo').forEach(el => el.remove());
            document.querySelectorAll('.casilla.ocupada').forEach(el => el.classList.remove('ocupada'));
            document.getElementById('enemigos-lista').innerHTML = '';
            enemigosCargados = [];
            
            // Realizar tirada según nivel de héroes
            const tirada = calcularTirada();
            const encuentro = encontrarEncuentroPorTirada(tirada.total);
            
            if (!encuentro) {
                alert('No se pudo encontrar un encuentro para la tirada realizada.');
                return;
            }
            
            // Mostrar información de la tirada
            document.getElementById('tirada-info').style.display = 'block';
            document.getElementById('tirada-detalle').innerHTML = `
                Nivel héroes: ${nivelHeroes}<br>
                Tirada D20: ${tirada.dado}<br>
                Modificador: +${tirada.modificador}<br>
                <strong>Total: ${tirada.total}</strong><br>
                Encuentro: ${encuentro.descripcion}
            `;
            
            // Procesar la descripción del encuentro para obtener enemigos
            const enemigos = procesarDescripcionEncuentro(encuentro.descripcion);
            
            if (enemigos.length === 0) {
                alert('No se pudieron procesar los enemigos de este encuentro.');
                return;
            }
            
            // Ordenar enemigos por tamaño (los más grandes primero)
            enemigos.sort((a, b) => {
                const sizeOrder = { 'NORMAL': 1, 'ENORME': 2, 'EXTRAENORME': 3 };
                return sizeOrder[b.tamano] - sizeOrder[a.tamano];
            });
            
            // Colocar enemigos
            for (const enemigo of enemigos) {
                const colocado = colocarEnemigo(enemigo);
                if (!colocado) {
                    console.warn('No se pudo colocar el enemigo:', enemigo.nombre);
                    // Continuar intentando con los demás enemigos
                }
            }
            
            // Mostrar lista de enemigos
            mostrarListaEnemigos();
            actualizarEstadisticas();
        }

        // Colocar enemigo en una casilla válida aleatoria
        function colocarEnemigo(enemigo) {
            // Encontrar todas las casillas válidas y disponibles
            const casillasValidas = [];
            const casillas = document.querySelectorAll('.casilla:not(.invalida):not(.ocupada)');
            
            casillas.forEach(casilla => {
                casillasValidas.push(casilla);
            });
            
            if (casillasValidas.length === 0) {
                console.warn('No hay casillas disponibles para colocar enemigos');
                return false;
            }
            
            // Mezclar casillas para obtener una posición aleatoria
            for (let i = casillasValidas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [casillasValidas[i], casillasValidas[j]] = [casillasValidas[j], casillasValidas[i]];
            }
            
            // Intentar colocar el enemigo
            for (const casilla of casillasValidas) {
                const fila = parseInt(casilla.dataset.fila);
                const columna = parseInt(casilla.dataset.columna);
                
                if (areaDisponible(fila, columna, enemigo.tamano)) {
                    // Marcar área como ocupada
                    marcarAreaOcupada(fila, columna, enemigo.tamano);
                    
                    // Obtener dimensiones
                    const dimensiones = obtenerDimensionesEnemigo(enemigo.tamano);
                    
                    // Crear elemento visual para el enemigo
                    const enemigoElement = document.createElement('div');
                    enemigoElement.className = `enemigo ${enemigo.tamano.toLowerCase()}`;
                    enemigoElement.title = `${enemigo.nombre} (${enemigo.tamano})`;
                    
                    // Calcular posición y tamaño
                    const matrizContainer = document.getElementById('matriz-loseta');
                    const cellWidth = matrizContainer.offsetWidth / losetaSeleccionada.matriz[0].length;
                    const cellHeight = matrizContainer.offsetHeight / losetaSeleccionada.matriz.length;
                    
                    enemigoElement.style.width = `${cellWidth * dimensiones.ancho - 10}px`;
                    enemigoElement.style.height = `${cellHeight * dimensiones.alto - 10}px`;
                    enemigoElement.style.left = `${columna * cellWidth + 5}px`;
                    enemigoElement.style.top = `${fila * cellHeight + 5}px`;
                    
                    // Añadir nombre abreviado si es necesario
                    let nombreMostrar = enemigo.nombre;
                    if (nombreMostrar.length > 12) {
                        nombreMostrar = nombreMostrar.substring(0, 10) + '...';
                    }
                    enemigoElement.textContent = nombreMostrar;
                    
                    // Añadir a la matriz
                    matrizContainer.appendChild(enemigoElement);
                    
                    // Guardar enemigo para la lista
                    enemigosCargados.push({
                        element: enemigoElement,
                        nombre: enemigo.nombre,
                        tamano: enemigo.tamano,
                        nivel: enemigo.nivel,
                        fila: fila,
                        columna: columna
                    });
                    
                    return true;
                }
            }
            
            return false;
        }

        // Mostrar lista de enemigos generados
        function mostrarListaEnemigos() {
            const lista = document.getElementById('enemigos-lista');
            lista.innerHTML = '';
            
            // Agrupar enemigos por nombre
            const enemigosAgrupados = {};
            enemigosCargados.forEach(enemigo => {
                if (!enemigosAgrupados[enemigo.nombre]) {
                    enemigosAgrupados[enemigo.nombre] = {
                        count: 0,
                        tamano: enemigo.tamano,
                        nivel: enemigo.nivel
                    };
                }
                enemigosAgrupados[enemigo.nombre].count++;
            });
            
            // Crear elementos para la lista
            for (const nombre in enemigosAgrupados) {
                const item = document.createElement('div');
                item.className = 'enemigo-item';
                
                const info = enemigosAgrupados[nombre];
                item.innerHTML = `
                    <strong>${nombre}</strong>
                    <div>Cantidad: ${info.count}</div>
                    <div>Tamaño: ${info.tamano}</div>
                    <div>Nivel: ${info.nivel}</div>
                `;
                
                lista.appendChild(item);
            }
        }

        // Actualizar estadísticas
        function actualizarEstadisticas() {
            const totalEnemigos = enemigosCargados.length;
            const nivelPromedio = nivelHeroes;
            
            // Calcular porcentaje de casillas ocupadas
            const totalCasillas = losetaSeleccionada.matriz.length * losetaSeleccionada.matriz[0].length;
            let casillasValidas = 0;
            let casillasOcupadas = 0;
            
            for (let i = 0; i < losetaSeleccionada.matriz.length; i++) {
                for (let j = 0; j < losetaSeleccionada.matriz[0].length; j++) {
                    if (losetaSeleccionada.matriz[i][j] === 1) {
                        casillasValidas++;
                    }
                }
            }
            
            // Contar casillas ocupadas
            document.querySelectorAll('.casilla.ocupada').forEach(() => {
                casillasOcupadas++;
            });
            
            const porcentajeOcupadas = casillasValidas > 0 ? Math.round((casillasOcupadas / casillasValidas) * 100) : 0;
            
            // Actualizar UI
            document.getElementById('total-enemigos').textContent = totalEnemigos;
            document.getElementById('nivel-promedio').textContent = nivelPromedio;
            document.getElementById('casillas-ocupadas').textContent = `${porcentajeOcupadas}%`;
        }
    </script>
</body>
</html>